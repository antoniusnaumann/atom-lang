+String(
    bytes UInt(8)*
)

+len(s String) Int {
    s.cstring::strlen()
}

// Determine UTF-8 sequence length from first byte
// Returns: 1 for ASCII, 2-4 for multibyte, 0 for invalid
-utf8_len(b UInt(8)) Int {
    match(True) {
        ((b & 0b10000000) == 0) { 1 }
        ((b & 0b11100000) == 0b11000000) { 2 }
        ((b & 0b11110000) == 0b11100000) { 3 }
        ((b & 0b11111000) == 0b11110000) { 4 }
        _ { 0 }
    }
}

// Decode a single UTF-8 sequence starting at index i
// Returns: (decoded_rune, bytes_consumed)
-decode_utf8_at(s String, i Int, seq_len Int) (Rune, Int) {
    byte_len := s.bytes.len()
    
    // Check if we have enough bytes for the sequence
    match((i + seq_len - 1) < byte_len) {
        False {
            // Not enough bytes - invalid sequence
            (0xFFFD, 1)
        }
        True {
            b := s.bytes(i)
            match(seq_len) {
                1 { (b, 1) }
                2 {
                    r := (((b & 0b00011111) << 6) | (s.bytes(i + 1) & 0b00111111))
                    (r, 2)
                }
                3 {
                    r := (((b & 0b00001111) << 12) | ((s.bytes(i + 1) & 0b00111111) << 6) | (s.bytes(i + 2) & 0b00111111))
                    (r, 3)
                }
                4 {
                    r := (((b & 0b00000111) << 18) | ((s.bytes(i + 1) & 0b00111111) << 12) | ((s.bytes(i + 2) & 0b00111111) << 6) | (s.bytes(i + 3) & 0b00111111))
                    (r, 4)
                }
                _ {
                    // Invalid sequence length
                    (0xFFFD, 1)
                }
            }
        }
    }
}

+runes(s String) Rune* {
    result: Rune*
    i := 0
    byte_len := s.bytes.len()
    
    loop(i < byte_len) {
        b := s.bytes(i)
        seq_len := utf8_len(b)
        (rune, consumed) := decode_utf8_at(s, i, seq_len)
        
        result ++= rune
        i += consumed
    }
    
    result
}

